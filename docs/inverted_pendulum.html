<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>台車型倒立振子シミュレーション</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #eee;
            color: #111;
            min-height: 100dvh;
            overflow-x: hidden;
        }
        .header {
            background: #fff;
            padding: 12px 16px;
            border-bottom: 2px solid #000;
            text-align: center;
        }
        .header h1 { font-size: 1rem; font-weight: 700; }
        .header .eq { font-size: 0.7rem; color: #666; margin-top: 2px; }

        .sensor-start {
            display: block;
            width: calc(100% - 32px);
            margin: 12px auto;
            padding: 16px;
            border: 2px solid #000;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            background: #000;
            color: #fff;
            transition: background 0.2s;
        }
        .sensor-start.active { background: #555; }
        .sensor-status {
            text-align: center;
            font-size: 0.8rem;
            color: #666;
            padding: 4px 0 8px;
        }
        .sensor-status.ok { color: #000; font-weight: 700; }
        .sensor-status.warn { color: #666; }
        .sensor-status.err { color: #333; font-weight: 700; }

        .canvas-wrap {
            background: #fff;
            margin: 0 8px 8px;
            border-radius: 10px;
            border: 2px solid #000;
            overflow: hidden;
            position: relative;
        }
        canvas { display: block; width: 100%; background: #fff; }

        .readout { display: flex; gap: 6px; margin: 0 8px 8px; }
        .readout-item {
            flex: 1;
            background: #fff;
            border: 1px solid #999;
            border-radius: 10px;
            padding: 10px 8px;
            text-align: center;
        }
        .readout-label { font-size: 0.65rem; color: #666; margin-bottom: 2px; }
        .readout-val {
            font-size: 1.1rem;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }
        .readout-unit { font-size: 0.6rem; color: #888; font-weight: 400; }

        .btn-row { display: flex; gap: 8px; margin: 0 8px 8px; }
        .btn-row button {
            flex: 1;
            padding: 12px;
            border: 2px solid #000;
            border-radius: 10px;
            background: #fff;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            color: #000;
        }
        .btn-row button:active { background: #ccc; }

        .settings-toggle {
            display: block;
            width: calc(100% - 16px);
            margin: 0 8px 8px;
            padding: 12px;
            border: 1px solid #999;
            border-radius: 10px;
            background: #fff;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            color: #333;
            text-align: left;
        }
        .settings-toggle::after { content: ' ▼'; float: right; }
        .settings-toggle.open::after { content: ' ▲'; }
        .settings-panel {
            display: none;
            margin: 0 8px 8px;
            padding: 16px;
            background: #fff;
            border: 1px solid #999;
            border-radius: 10px;
        }
        .settings-panel.open { display: block; }
        .ctrl { margin-bottom: 14px; }
        .ctrl:last-child { margin-bottom: 0; }
        .ctrl label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #333;
            margin-bottom: 4px;
        }
        .ctrl label span { color: #666; font-variant-numeric: tabular-nums; }
        .ctrl input[type="range"] { width: 100%; cursor: pointer; }
        .pm-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .pm-btn {
            width: 44px; height: 44px;
            border: 2px solid #000;
            border-radius: 8px;
            background: #fff;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            color: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .pm-btn:active { background: #ccc; }
        .pm-btn.pm-wide { width: 100%; font-size: 1.4rem; }
        .pm-val {
            flex: 1;
            text-align: center;
            font-size: 1.1rem;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }

        /* タイマー大表示 */
        .timer-display {
            text-align: center;
            margin: 0 8px 8px;
            padding: 12px;
            background: #fff;
            border: 2px solid #000;
            border-radius: 10px;
        }
        .timer-display .timer-label { font-size: 0.75rem; color: #666; }
        .timer-display .timer-val {
            font-size: 2.2rem;
            font-weight: 800;
            font-variant-numeric: tabular-nums;
            color: #000;
        }
        .timer-display .timer-unit { font-size: 0.8rem; color: #666; }

        /* ゲームオーバー */
        .overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        .overlay.show { display: flex; }
        .overlay-box {
            background: #fff;
            border-radius: 16px;
            padding: 32px 28px;
            text-align: center;
            max-width: 320px;
            width: 90%;
            border: 3px solid #000;
        }
        .overlay-box h2 {
            font-size: 1.3rem;
            margin-bottom: 8px;
            color: #000;
        }
        .overlay-box .result-time {
            font-size: 3rem;
            font-weight: 800;
            color: #000;
            margin: 12px 0;
            font-variant-numeric: tabular-nums;
        }
        .overlay-box .result-unit {
            font-size: 1rem;
            color: #666;
        }
        .overlay-box .result-msg {
            font-size: 0.85rem;
            color: #444;
            margin: 8px 0 20px;
        }
        .overlay-box button {
            width: 100%;
            padding: 14px;
            border: 2px solid #000;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            background: #000;
            color: #fff;
        }

        /* ベストスコア */
        .best-score {
            text-align: center;
            margin: 0 8px 8px;
            padding: 8px;
            background: #fff;
            border: 2px solid #000;
            border-radius: 10px;
            font-size: 0.8rem;
            color: #000;
            font-weight: 600;
        }
    </style>
</head>
<body>

<div class="header">
    <h1>台車型倒立振子バランスゲーム</h1>
    <div class="eq">(M+m)ẍ + mLθ̈cosθ = F,　Lθ̈ + ẍcosθ = gsinθ − μθ̇</div>
</div>

<button class="sensor-start" id="sensorBtn">&#9654; センサーを起動してスタート</button>
<div class="sensor-status" id="sensorStatus">スマホを傾けて台車を操作し、振子を立て続けよう</div>

<div class="timer-display">
    <div class="timer-label">経過時間</div>
    <div class="timer-val"><span id="timerVal">0.00</span><span class="timer-unit"> 秒</span></div>
</div>

<div class="best-score" id="bestScoreBar">ベスト記録: --</div>

<div class="canvas-wrap">
    <canvas id="mainCanvas" height="320"></canvas>
</div>

<div class="readout">
    <div class="readout-item">
        <div class="readout-label">台車位置</div>
        <div class="readout-val"><span id="valCart">0.0</span><span class="readout-unit"> cm</span></div>
    </div>
    <div class="readout-item">
        <div class="readout-label">振子角度</div>
        <div class="readout-val"><span id="valAngle">0.0</span><span class="readout-unit"> °</span></div>
    </div>
    <div class="readout-item">
        <div class="readout-label">加速度入力</div>
        <div class="readout-val"><span id="valAccel">0.0</span><span class="readout-unit"> m/s²</span></div>
    </div>
</div>

<div class="btn-row">
    <button id="resetBtn">リセット</button>
    <button id="pauseBtn">一時停止</button>
</div>

<button class="settings-toggle" id="settingsToggle">パラメータ設定</button>
<div class="settings-panel" id="settingsPanel">
    <div class="ctrl">
        <label>振子質量 m <span id="pendMassValue">0.3 kg</span></label>
        <input type="range" id="pendMass" min="0.1" max="5.0" step="0.1" value="0.3">
    </div>
    <div class="ctrl">
        <label>台車質量 M <span id="cartMassValue">5.0 kg</span></label>
        <input type="range" id="cartMass" min="0.5" max="10.0" step="0.5" value="5.0">
    </div>
    <div class="ctrl">
        <label>振子の長さ L <span id="lengthValue">3.0 m</span></label>
        <input type="range" id="pendLength" min="0.3" max="5.0" step="0.1" value="3.0">
    </div>
    <div class="ctrl">
        <label>空気抵抗 μ <span id="dampValue">0.80</span></label>
        <input type="range" id="damping" min="0" max="10.0" step="0.1" value="0.80">
    </div>
    <div class="ctrl">
        <label>センサー感度</label>
        <div class="pm-row">
            <button class="pm-btn" id="sensDown">−</button>
            <span class="pm-val" id="sensValue">2.0</span>
            <button class="pm-btn" id="sensUp">＋</button>
        </div>
    </div>
    <div class="ctrl">
        <label>入力軸</label>
        <div class="pm-row">
            <button class="pm-btn" id="axisDown">◀</button>
            <span class="pm-val" id="axisValue">X</span>
            <button class="pm-btn" id="axisUp">▶</button>
        </div>
    </div>
    <div class="ctrl">
        <label>入力の符号（向きが逆なら切替）</label>
        <div class="pm-row">
            <button class="pm-btn pm-wide" id="signToggle">＋</button>
        </div>
    </div>
    <div class="ctrl">
        <label>転倒判定角度 <span id="fallAngleValue">90°</span></label>
        <input type="range" id="fallAngle" min="20" max="120" step="5" value="90">
    </div>
    <div class="ctrl">
        <label>初期角度 <span id="initAngleValue">5°</span></label>
        <input type="range" id="initAngle" min="1" max="15" step="1" value="5">
    </div>
</div>

<!-- ゲームオーバー -->
<div class="overlay" id="overlay">
    <div class="overlay-box">
        <h2>倒れた！</h2>
        <div class="result-time" id="resultTime">0.00</div>
        <div class="result-unit">秒</div>
        <div class="result-msg" id="resultMsg"></div>
        <button id="retryBtn">もう一度チャレンジ</button>
    </div>
</div>

<script>
// --- キャンバス設定 ---
const mainCanvas = document.getElementById('mainCanvas');
const ctx = mainCanvas.getContext('2d');
const CANVAS_H = 320;

function fitCanvas() {
    const rect = mainCanvas.parentElement.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    mainCanvas.width = rect.width * dpr;
    mainCanvas.height = CANVAS_H * dpr;
    mainCanvas.style.height = CANVAS_H + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
fitCanvas();
window.addEventListener('resize', fitCanvas);

// --- パラメータ ---
let mPend = 0.3;       // 振子質量 (kg) 軽い方が操作しやすい
let mCart = 5.0;       // 台車質量 (kg) 重い方が安定
let L = 3.0;           // 振子長さ (m) 長い方がゆっくり倒れる
let mu = 0.8;          // 空気抵抗係数 大きい方がゆっくり
let sensitivity = 2.0; // センサー感度
let fallAngleDeg = 90; // 転倒判定角度 90°=水平で転倒
let initAngleDeg = 5;  // 初期角度
const g = 9.81;

// --- 状態変数 ---
let theta = 0;       // 振子角度 (rad) 0=直立
let thetaDot = 0;    // 角速度
let cartX = 0;       // 台車位置 (m)
let cartV = 0;       // 台車速度
let cartAccel = 0;   // 台車加速度 (センサー入力)
let simTime = 0;
let gameState = 'idle'; // idle | running | paused | fallen
let bestTime = parseFloat(localStorage.getItem('invertedPendulumBest') || '0');

// --- 加速度センサー ---
let sensorActive = false;
let sensorAccel = { x: 0, y: 0, z: 0 };
let sensorFiltered = 0;  // ローパスフィルタ済みの値
let sensorAxis = 'x';
let sensorSign = 1;      // +1 or -1（符号反転用）

const $ = id => document.getElementById(id);

// ベストスコア表示更新
function updateBestScore() {
    $('bestScoreBar').textContent = bestTime > 0
        ? 'ベスト記録: ' + bestTime.toFixed(2) + ' 秒'
        : 'ベスト記録: --';
}
updateBestScore();

// --- センサー制御 ---
function handleSensorMotion(event) {
    const acc = event.accelerationIncludingGravity || {};
    sensorAccel.x = acc.x ?? 0;
    sensorAccel.y = acc.y ?? 0;
    sensorAccel.z = acc.z ?? 0;
    if (!sensorActive) {
        sensorActive = true;
        $('sensorStatus').textContent = 'センサー計測中';
        $('sensorStatus').className = 'sensor-status ok';
    }
}

async function toggleSensor() {
    if ($('sensorBtn').classList.contains('active')) {
        window.removeEventListener('devicemotion', handleSensorMotion);
        sensorActive = false;
        sensorAccel = { x: 0, y: 0, z: 0 };
        $('sensorBtn').classList.remove('active');
        $('sensorBtn').textContent = '\u25B6 センサーを起動してスタート';
        $('sensorStatus').textContent = '停止中';
        $('sensorStatus').className = 'sensor-status';
        gameState = 'idle';
        return;
    }
    if (!('DeviceMotionEvent' in window)) {
        $('sensorStatus').textContent = 'このブラウザは加速度センサー非対応です';
        $('sensorStatus').className = 'sensor-status err';
        return;
    }
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
        try {
            const perm = await DeviceMotionEvent.requestPermission();
            if (perm !== 'granted') {
                $('sensorStatus').textContent = 'センサーアクセスが拒否されました';
                $('sensorStatus').className = 'sensor-status err';
                return;
            }
        } catch (e) {
            $('sensorStatus').textContent = '権限リクエスト失敗: ' + e.message;
            $('sensorStatus').className = 'sensor-status err';
            return;
        }
    }
    window.addEventListener('devicemotion', handleSensorMotion);
    $('sensorBtn').classList.add('active');
    $('sensorBtn').textContent = '\u25A0 センサーを停止';
    $('sensorStatus').textContent = 'センサー起動中...';
    $('sensorStatus').className = 'sensor-status warn';

    setTimeout(() => {
        if (!sensorActive) {
            $('sensorStatus').textContent = 'データ受信なし。HTTPS環境のスマホでアクセスしてください';
            $('sensorStatus').className = 'sensor-status err';
        }
    }, 2000);

    // ゲーム開始
    resetGame();
    gameState = 'running';
}
$('sensorBtn').addEventListener('click', toggleSensor);

// --- PC用キーボード操作 ---
let keyLeft = false, keyRight = false;
window.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft') keyLeft = true;
    if (e.key === 'ArrowRight') keyRight = true;
    if (e.key === ' ' && gameState === 'idle') {
        resetGame();
        gameState = 'running';
    }
});
window.addEventListener('keyup', e => {
    if (e.key === 'ArrowLeft') keyLeft = false;
    if (e.key === 'ArrowRight') keyRight = false;
});

// キャンバスタップでスタート（idle時のみ）
mainCanvas.addEventListener('click', () => {
    if (gameState === 'idle') {
        resetGame();
        gameState = 'running';
    }
});

// --- ゲームリセット ---
function resetGame() {
    const initRad = initAngleDeg * Math.PI / 180;
    theta = (Math.random() > 0.5 ? 1 : -1) * initRad;
    thetaDot = 0;
    cartX = 0;
    cartV = 0;
    cartAccel = 0;
    sensorFiltered = 0;
    simTime = 0;
    $('timerVal').textContent = '0.00';
    $('overlay').classList.remove('show');
}

// --- 物理シミュレーション (RK4) ---
function simulate(dt) {
    // センサー入力（シンプル: 選択軸の値 × 符号）
    let rawInput = 0;
    if (sensorActive) {
        if (sensorAxis === 'x') rawInput = sensorAccel.x;
        else if (sensorAxis === 'y') rawInput = sensorAccel.y;
        else rawInput = sensorAccel.z;
        rawInput *= sensorSign;
    }
    // ローパスフィルタ (alpha小=滑らか, 大=敏感)
    const alpha = 0.15;
    sensorFiltered += alpha * (rawInput - sensorFiltered);
    let accelInput = sensorFiltered * sensitivity;

    // キーボード入力
    if (keyLeft) accelInput -= 12;
    if (keyRight) accelInput += 12;

    // 台車加速度に上限を設定
    const maxAccel = 20;
    accelInput = Math.max(-maxAccel, Math.min(maxAccel, accelInput));

    // 外力 F = (M+m) * accelInput（センサー入力を力に変換）
    const F = (mCart + mPend) * accelInput;

    // 連成運動方程式 (台車+振子)
    // (M+m)ẍ + mL θ̈ cosθ − mL θ̇² sinθ = F − friction
    // L θ̈ + ẍ cosθ − g sinθ + μ θ̇ = 0
    // → θ̈, ẍ を連立で解く
    function calcAccels(th, thd, cv) {
        const sinT = Math.sin(th), cosT = Math.cos(th);
        const Mt = mCart + mPend;
        const denom = Mt * L - mPend * L * cosT * cosT;
        const friction = 0.5 * cv; // 台車摩擦
        const thAcc = (Mt * g * sinT - cosT * (F - friction + mPend * L * thd * thd * sinT) - Mt * mu * thd) / denom;
        const xAcc = (F - friction + mPend * L * (thd * thd * sinT - thAcc * cosT)) / Mt;
        return { thAcc, xAcc };
    }

    cartAccel = accelInput;

    // RK4 (θ, θ̇, x, ẋ の4変数)
    const a1 = calcAccels(theta, thetaDot, cartV);
    const k1th = thetaDot, k1w = a1.thAcc, k1x = cartV, k1v = a1.xAcc;

    const a2 = calcAccels(theta + k1th*dt/2, thetaDot + k1w*dt/2, cartV + k1v*dt/2);
    const k2th = thetaDot + k1w*dt/2, k2w = a2.thAcc, k2x = cartV + k1v*dt/2, k2v = a2.xAcc;

    const a3 = calcAccels(theta + k2th*dt/2, thetaDot + k2w*dt/2, cartV + k2v*dt/2);
    const k3th = thetaDot + k2w*dt/2, k3w = a3.thAcc, k3x = cartV + k2v*dt/2, k3v = a3.xAcc;

    const a4 = calcAccels(theta + k3th*dt, thetaDot + k3w*dt, cartV + k3v*dt);
    const k4th = thetaDot + k3w*dt, k4w = a4.thAcc, k4x = cartV + k3v*dt, k4v = a4.xAcc;

    theta    += (k1th + 2*k2th + 2*k3th + k4th) * dt / 6;
    thetaDot += (k1w  + 2*k2w  + 2*k3w  + k4w ) * dt / 6;
    cartX    += (k1x  + 2*k2x  + 2*k3x  + k4x ) * dt / 6;
    cartV    += (k1v  + 2*k2v  + 2*k3v  + k4v ) * dt / 6;

    // 移動制限なし（カメラが追従する）

    simTime += dt;

    // 転倒判定
    const fallRad = fallAngleDeg * Math.PI / 180;
    if (Math.abs(theta) > fallRad) {
        return true; // 転倒
    }
    return false;
}

// --- 描画 ---
function draw() {
    const W = mainCanvas.width / (window.devicePixelRatio || 1);
    const H = CANVAS_H;
    ctx.clearRect(0, 0, W, H);

    const centerX = W / 2;
    const groundY = H - 50;
    const scale = W / 5; // 1m = scale px

    // カメラオフセット: 台車が常に画面中央に来る
    const camOffset = cartX * scale;

    // 地面
    ctx.fillStyle = '#ddd';
    ctx.fillRect(0, groundY, W, H - groundY);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, groundY);
    ctx.lineTo(W, groundY);
    ctx.stroke();

    // グリッド線（1mごと、カメラ追従でスクロール）
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 0.5;
    const gridOffset = camOffset % scale;
    const gridCenter = Math.round(cartX);
    for (let i = -4; i <= 4; i++) {
        const gx = centerX + i * scale - gridOffset;
        ctx.beginPath();
        ctx.moveTo(gx, 0);
        ctx.lineTo(gx, groundY);
        ctx.stroke();
    }

    // 目盛り（カメラ追従）
    ctx.fillStyle = '#999';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    for (let i = -3; i <= 3; i++) {
        const worldM = gridCenter + i;
        const gx = centerX + (worldM - cartX) * scale;
        ctx.fillText(worldM + 'm', gx, groundY + 14);
    }

    // --- 台車（常に画面中央） ---
    const cartPxX = centerX;
    const cartW = 70, cartH = 30;
    const wheelR = 8;

    // 車輪
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(cartPxX - cartW / 3, groundY - wheelR, wheelR, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(cartPxX + cartW / 3, groundY - wheelR, wheelR, 0, Math.PI * 2);
    ctx.fill();

    // 本体
    const cartTop = groundY - wheelR * 2 - cartH;
    ctx.fillStyle = '#aaa';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    roundRect(ctx, cartPxX - cartW / 2, cartTop, cartW, cartH, 5);
    ctx.fill();
    ctx.stroke();

    // 台車ラベル
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('M', cartPxX, cartTop + cartH / 2 + 4);

    // --- 振子 ---
    const pivotX = cartPxX;
    const pivotY = cartTop;
    // 棒を画面内に収める: ピボットから上端まで-余白20pxに収まるよう自動スケール
    const maxPendPx = pivotY - 20;
    const pendLen = Math.min(L * scale * 0.7, maxPendPx);

    // 振子先端（質量）の位置
    const bobX = pivotX + pendLen * Math.sin(theta);
    const bobY = pivotY - pendLen * Math.cos(theta);

    // 棒
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(pivotX, pivotY);
    ctx.lineTo(bobX, bobY);
    ctx.stroke();

    // ピボット点
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(pivotX, pivotY, 5, 0, Math.PI * 2);
    ctx.fill();

    // 質量（ボブ）
    const bobR = 14;
    ctx.fillStyle = '#333';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(bobX, bobY, bobR, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 10px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('m', bobX, bobY + 4);

    // --- 角度表示の弧 ---
    if (Math.abs(theta) > 0.02) {
        const arcR = 30;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([3, 3]);
        // 直立の基準線
        ctx.beginPath();
        ctx.moveTo(pivotX, pivotY);
        ctx.lineTo(pivotX, pivotY - arcR - 10);
        ctx.stroke();
        ctx.setLineDash([]);
        // 弧
        ctx.beginPath();
        const startAngle = -Math.PI / 2;
        const endAngle = -Math.PI / 2 + theta;
        ctx.arc(pivotX, pivotY, arcR, Math.min(startAngle, endAngle), Math.max(startAngle, endAngle));
        ctx.stroke();
    }

    // --- 加速度入力表示（矢印） ---
    if (Math.abs(cartAccel) > 0.5) {
        const arrowLen = Math.min(Math.abs(cartAccel) * 4, 50);
        const arrowDir = cartAccel > 0 ? 1 : -1;
        const arrowY = cartTop + cartH / 2;
        const arrowStartX = cartPxX + arrowDir * (cartW / 2 + 5);
        const arrowEndX = arrowStartX + arrowDir * arrowLen;

        ctx.strokeStyle = '#000';
        ctx.fillStyle = '#000';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(arrowStartX, arrowY);
        ctx.lineTo(arrowEndX, arrowY);
        ctx.stroke();
        // 矢じり
        ctx.beginPath();
        ctx.moveTo(arrowEndX, arrowY);
        ctx.lineTo(arrowEndX - arrowDir * 8, arrowY - 5);
        ctx.lineTo(arrowEndX - arrowDir * 8, arrowY + 5);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = '#000';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('a', arrowStartX + arrowDir * arrowLen / 2, arrowY - 10);
    }

    // --- ゲーム状態表示 ---
    if (gameState === 'idle') {
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 18px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('タップ / スペースキーでスタート', centerX, H / 2 - 16);
        ctx.font = '12px sans-serif';
        ctx.fillText('スマホ: センサーを起動して傾けて操作', centerX, H / 2 + 8);
        ctx.fillText('PC: ←→キーで操作', centerX, H / 2 + 26);
        ctx.font = '11px sans-serif';
        ctx.fillStyle = '#ccc';
        ctx.fillText('※ 下の設定パネルで軸・感度を調整できます', centerX, H / 2 + 48);
    }

    if (gameState === 'paused') {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 18px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('一時停止中', centerX, H / 2);
    }
}

function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
}

// --- 転倒処理 ---
function onFallen() {
    gameState = 'fallen';
    const time = simTime;

    // ベスト更新チェック
    let isNewBest = false;
    if (time > bestTime) {
        bestTime = time;
        localStorage.setItem('invertedPendulumBest', bestTime.toString());
        isNewBest = true;
        updateBestScore();
    }

    $('resultTime').textContent = time.toFixed(2);

    let msg = '';
    if (isNewBest) {
        msg = '新記録！ ベスト更新！';
        $('overlay').querySelector('h2').textContent = '新記録！';
        $('overlay').querySelector('h2').style.color = '#000';
    } else {
        $('overlay').querySelector('h2').textContent = '倒れた！';
        $('overlay').querySelector('h2').style.color = '#000';
        if (time < 1) msg = 'もう少しがんばろう！';
        else if (time < 3) msg = 'いい感じ！もっと長く保てるかも？';
        else if (time < 10) msg = 'なかなかの腕前！';
        else if (time < 30) msg = 'すごい！安定してます！';
        else msg = '達人レベル！';
    }
    $('resultMsg').textContent = msg;
    $('overlay').classList.add('show');
}

// --- UI イベント ---
$('resetBtn').addEventListener('click', () => {
    resetGame();
    if (sensorActive || keyLeft || keyRight) {
        gameState = 'running';
    } else {
        gameState = 'idle';
    }
});

$('pauseBtn').addEventListener('click', () => {
    if (gameState === 'running') {
        gameState = 'paused';
        $('pauseBtn').textContent = '再開';
    } else if (gameState === 'paused') {
        gameState = 'running';
        $('pauseBtn').textContent = '一時停止';
    }
});

$('retryBtn').addEventListener('click', () => {
    resetGame();
    gameState = 'idle'; // すぐ始めず待機→設定変更可能
    $('pauseBtn').textContent = '一時停止';
});

$('settingsToggle').addEventListener('click', () => {
    $('settingsToggle').classList.toggle('open');
    $('settingsPanel').classList.toggle('open');
});

$('pendMass').addEventListener('input', e => {
    mPend = parseFloat(e.target.value);
    $('pendMassValue').textContent = mPend.toFixed(1) + ' kg';
});
$('cartMass').addEventListener('input', e => {
    mCart = parseFloat(e.target.value);
    $('cartMassValue').textContent = mCart.toFixed(1) + ' kg';
});
$('pendLength').addEventListener('input', e => {
    L = parseFloat(e.target.value);
    $('lengthValue').textContent = L.toFixed(1) + ' m';
});
$('damping').addEventListener('input', e => {
    mu = parseFloat(e.target.value);
    $('dampValue').textContent = mu.toFixed(2);
});
// 感度 +/- ボタン
$('sensUp').addEventListener('click', () => {
    sensitivity = Math.min(20, sensitivity + 0.5);
    $('sensValue').textContent = sensitivity.toFixed(1);
});
$('sensDown').addEventListener('click', () => {
    sensitivity = Math.max(0.5, sensitivity - 0.5);
    $('sensValue').textContent = sensitivity.toFixed(1);
});
// 入力軸 切替ボタン
const axes = ['x', 'y', 'z'];
const axisLabels = { x: 'X', y: 'Y', z: 'Z' };
function updateAxisUI() { $('axisValue').textContent = axisLabels[sensorAxis]; }
$('axisUp').addEventListener('click', () => {
    let i = axes.indexOf(sensorAxis);
    sensorAxis = axes[(i + 1) % axes.length];
    updateAxisUI();
});
$('axisDown').addEventListener('click', () => {
    let i = axes.indexOf(sensorAxis);
    sensorAxis = axes[(i + axes.length - 1) % axes.length];
    updateAxisUI();
});
// 符号トグルボタン
function updateSignUI() { $('signToggle').textContent = sensorSign > 0 ? '＋' : '−'; }
$('signToggle').addEventListener('click', () => {
    sensorSign *= -1;
    updateSignUI();
});
$('fallAngle').addEventListener('input', e => {
    fallAngleDeg = parseInt(e.target.value);
    $('fallAngleValue').textContent = fallAngleDeg + '°';
});
$('initAngle').addEventListener('input', e => {
    initAngleDeg = parseInt(e.target.value);
    $('initAngleValue').textContent = initAngleDeg + '°';
});

// --- メインループ ---
const DT = 1 / 60;
const PHYSICS_STEPS = 4; // 物理を細かく計算
const PHYSICS_DT = DT / PHYSICS_STEPS;

function mainLoop() {
    if (gameState === 'running') {
        for (let i = 0; i < PHYSICS_STEPS; i++) {
            const fallen = simulate(PHYSICS_DT);
            if (fallen) {
                onFallen();
                break;
            }
        }
        $('timerVal').textContent = simTime.toFixed(2);
    }

    draw();

    // 数値表示
    $('valCart').textContent = (cartX * 100).toFixed(1);
    $('valAngle').textContent = (theta * 180 / Math.PI).toFixed(1);
    $('valAccel').textContent = cartAccel.toFixed(1);

    requestAnimationFrame(mainLoop);
}

resetGame();
gameState = 'idle';
mainLoop();
</script>
</body>
</html>
